<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!--Generated from database. Edit in the database; do not edit this file.-->

<title>JKI EasyXML Functions</title>
<link rel="STYLESHEET" type="text/css" href="../../OpenG/common/minimal.css">

<script src="../../OpenG/common/web.js" type="text/javascript"></script>
<script src="../../OpenG/common/helpserver.js" type="text/javascript"></script>
<script src="../../OpenG/common/DynamicContent.js" type="text/javascript"></script>
</head>
<BODY onLoad='initPageNoAdjust();' bgcolor="#ffffff">
<noscript>
<p class="Body">Enable Javascript to enable more features in this page.</p>
<hr width="100%" noshade>
</noscript>
<h1>JKI EasyXML Functions</h1>
<p class="Body">The JKI EasyXML functions allow you to easily create and parse XML data and files.  The main advantage is that EasyXML does not use the LabVIEW data schema defined by NI (<LabVIEW>\vi.lib\Utility\LVXMLSchema.xsd).  Instead, it uses the data names as the XML entity names, allowing users to quickly and easily write and read arbitrary XML data.  Additionally, EasyXML supports XML entity attributes.</p>
<!-- Graphic Reference -->
<p><img src="JKI_EasyXML_Palette.png" border="0"></p>

<table class="Borderless"><tr>
<td><a href="javascript:openLLB('examples\\JKI\\EasyXML');"><img src="../../OpenG/common/minibutton.gif" border="0"></a>&nbsp;Open examples from <span class="Monospace">examples\JKI\EasyXML</span></td>
</tr></table>

<table class="Bordered-Wide"><tr><th class="Bordered Left-Align">Palette Object</th><th class="Bordered Left-Align">Description</th></tr>
<tr><td class="Bordered"><a href="Easy_Generate_XML.htm">Easy Generate XML</a></td><td class="Bordered">Converts <B>LabVIEW Data</B> to an XML string with the LabVIEW data names (labels) converted to XML item names and the LabVIEW data values converted to XML item values.</td></tr>
<tr><td class="Bordered"><a href="Easy_Parse_XML.htm">Easy Parse XML</a></td><td class="Bordered">Converts an <B>XML String</B> to <B>LabVIEW Data</B>, based on the <B>LabVIEW Data (Type)</B> argument.  Use the <B>Variant to Data</B> function to convert the output variant <B>LabVIEW Data</B> to the desired data type.</td></tr>
<tr><td class="Bordered"><a href="Easy_Write_XML_File.htm">Easy Write XML File</a></td><td class="Bordered">Converts <B>LabVIEW Data</B> to an XML string and writes it to an XML file with the LabVIEW data names (labels) converted to XML item names and the LabVIEW data values converted to XML item values.</td></tr>
<tr><td class="Bordered"><a href="Easy_Read_XML_File.htm">Easy Read XML File</a></td><td class="Bordered">Reads and parses data from an XML file (specified by the <B>XML File Path</B> input), converting it into <B>LabVIEW Data</B>, based on the <B>LabVIEW Data (Type)</B> argument.  Use the <B>Variant to Data</B> function to convert the output variant <B>LabVIEW Data</B> to the desired data type.</td></tr>
</table></p>

<h2><a name="examples">Examples</a></h2>
<p class="Body">Refer to the <span class="Monospace">examples\JKI\EasyXML</span> for examples of using the JKI EasyXML Functions.</p>
<p class="Body"><a href="javascript:openLLB('examples\\JKI\\EasyXML');"><img src="../../OpenG/common/minibutton.gif" border="0"></a>&nbsp;Open examples&nbsp;</p>

<h2><a name="examples">Detailed Documentation</a></h2>
<p class="Body"><span style="font-weight: bold;">EasyXML vs. LabVIEW's
built-in XML</span><br>
The LabVIEW Flatten to XML output, shown below, is focus on LabVIEW
data type, whereas the EasyXML output is more focused on the data names
and structure, mapping the data names to entity names and data values
to entity text (#TEXT):<br>
<br>
LabVIEW's built-in XML output:<br>
<br>
&lt;Cluster&gt;<br>
&lt;Name&gt;My XML Data&lt;/Name&gt;<br>
&lt;NumElts&gt;2&lt;/NumElts&gt;<br>
&lt;DBL&gt;<br>
&lt;Name&gt;My Number&lt;/Name&gt;<br>
&lt;Val&gt;1.23000&lt;/Val&gt;<br>
&lt;/DBL&gt;<br>
&lt;Boolean&gt;<br>
&lt;Name&gt;My Boolean&lt;/Name&gt;<br>
&lt;Val&gt;1&lt;/Val&gt;<br>
&lt;/Boolean&gt;<br>
&lt;/Cluster&gt;<br>
<br>
EasyXML output:<br>
<br>
&lt;My_XML_Data&gt;<br>
&nbsp; &lt;My_Number&gt;1.23&lt;/My_Number&gt;<br>
&nbsp; &lt;My_Boolean&gt;TRUE&lt;/My_Boolean&gt;<br>
&lt;/My_XML_Data&gt;<br>
<br>
Additionally, the EasyXML library also supports attributes, as shown by
the <span style="font-style: italic;">version</span>
and <span style="font-style: italic;">author</span>
attributes of the My_XML_Data entity below:<br>
<br>
&lt;My_XML_Data version="2.1" author="Jane Doe"&gt;<br>
&nbsp; &lt;My_Number&gt;1.23&lt;/My_Number&gt;<br>
&nbsp; &lt;My_Boolean&gt;TRUE&lt;/My_Boolean&gt;<br>
&lt;/My_XML_Data&gt;<br>
<br>
<span style="font-weight: bold;">Element and Attribute
Names</span><br>
LabVIEW data names map to element and attribute names.&nbsp; The
LabVIEW data names will be converted to legal XML entity names if they
contain any illegal entity name characters. Leading and trailing
whitespace will be removed (trimmed). Whitespace characters within the
data name will be converted to underscores.&nbsp; Other illegal
characters will simply be removed.<br>
<br>
<span style="font-weight: bold;">Compound Elements
(Clusters)</span><br>
LabVIEW clusters are used for compound XML elements (elements with
child elements).&nbsp; For example, here is some XML with compound
elements:<br>
<br>
&lt;Company&gt;<br>
&nbsp; &lt;Name&gt;JKI&lt;/Name&gt;<br>
&nbsp; &lt;Location&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;City&gt;San
Francisco&lt;/City&gt;<br>
&nbsp;&nbsp;&nbsp;
&lt;Country&gt;USA&lt;/Country&gt;<br>
&nbsp; &lt;/Location&gt;<br>
&lt;/Company&gt;<br>
<br>
<span style="font-weight: bold;">Multiple Elements of the
Same Name (Arrays)</span><br>
Arrays can be used to handle multiple XML elements of the same
name.&nbsp; When using LabVIEW arrays, the array name, not the
array element name, is used as the xml element name.&nbsp; For
example, if we have a cluster named "employees" that contains an array
(of strings) named "person", we might get something like the following:<br>
<br>
&lt;employees&gt;<br>
&nbsp; &lt;person&gt;Jack&lt;/person&gt;<br>
&nbsp; &lt;person&gt;Jill&lt;/person&gt;<br>
&nbsp; &lt;person&gt;Bob&lt;/person&gt;<br>
&lt;/employees&gt;<br>
<br>
<span style="font-weight: bold;">Empty Element Tags</span><br>
LabVIEW data with a null value will generate an empty
element.&nbsp; For example:<br>
<br>
&lt;empty_element/&gt; instead of
&lt;empty_element&gt;&lt;/empty_element&gt;<br>
<br>
Note: One exception to this rule is an empty array.&nbsp; Since an
array represents an ordered set of elements, an empty array represents
no elements.<br>
<br>
<span style="font-weight: bold;">Scalar Elements</span><br>
Scalar XML elements have no child elements. They consist of string
data.&nbsp; For example, below is a scalar element named "State"
with a value of "California":<br>
&nbsp;&nbsp; &nbsp;<br>
&lt;State&gt;California&lt;/State&gt;<br>
<br>
Scalar elements are created from any supported LabVIEW data type, other
than clusters (which are used for compound/nested elements).<br>
<br>
<span style="font-weight: bold;">Supported LabVIEW Data
Types and Formatting</span><br>
Below is a table showing the formatting of LabVIEW data types:<br>
<span style="font-weight: bold;">String</span>: <a
 href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#string">xml
string primitive</a> format<br>
<span style="font-weight: bold;">Path</span>:&nbsp;
<a
 href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#string">xml
string primitive</a> format<br>
<span style="font-weight: bold;">Integer</span>: <a
 href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#decimal">xml
decimal primitive</a> format<br>
<span style="font-weight: bold;">Floating Point</span>:
uses the <a href="http://www.w3.org/TR/xmlschema-2/#float">xml
float primitive</a> format &nbsp;Generated XML will use
LabVIEW's automatic formatting (%#g). Parsed xml supports <br>
<span style="font-weight: bold;">Boolean</span>:
uses the <a href="http://www.w3.org/TR/xmlschema-2/#boolean">xml
boolean primitive</a> format &nbsp;Generated xml will
be&nbsp;<span style="font-family: monospace;">true</span>
or&nbsp;<span style="font-family: monospace;">false</span>
and parsed xml may be&nbsp;<span style="font-family: monospace;">true</span>,
<span style="font-family: monospace;">false</span>, <span
 style="font-family: monospace;">1</span>, or&nbsp;<span
 style="font-family: monospace;">0</span> (case
insensitive).<br>
<span style="font-weight: bold;">Time Stamp</span>:
uses the <a href="http://www.w3.org/TR/xmlschema-2/#dateTime">xml
dateTime primitive</a> format &nbsp;Generated xml includes
date and time with millisecond precision and local timezone designation
(for example: <span style="font-family: monospace;">2008-03-17T13:02:03.123-08:00</span>)
. Parsed xml supports date with optional time and local or UTC timezone.<br>
<br>
<span style="font-weight: bold;">Escaping and Unescaping
XML in Element and Attribute Values</span><br>
All data will be escaped in the&nbsp;XML values, such that it does
not
include any special XML characters (see Table below).&nbsp; This
means that instances of these characters must be converted to escape
code.<br>
<br>
Element or Attribute&nbsp;&nbsp; &nbsp;Special
Character&nbsp;&nbsp; &nbsp;Escape Code<br>
Both&nbsp;&nbsp; &nbsp;&amp;&nbsp;&nbsp;
&nbsp;&amp;amp;<br>
Both&nbsp;&nbsp; &nbsp;&gt;&nbsp;&nbsp;
&nbsp;&amp;gt;<br>
Both&nbsp;&nbsp; &nbsp;&lt;&nbsp;&nbsp;
&nbsp;&amp;lt;<br>
Attribute Only&nbsp;&nbsp; &nbsp;'&nbsp;&nbsp;
&nbsp;&amp;apos;<br>
Attribute Only&nbsp;&nbsp; &nbsp;"&nbsp;&nbsp;
&nbsp;&amp;quot;<br>
<br>
<span style="font-weight: bold;">Adding XML Attributes
using an "#attributes" Cluster</span><br>
XML elements can have attributes.&nbsp; For example, below is an
xml element having two attributes:<br>
&nbsp;&nbsp; &nbsp;<br>
&lt;my_element attribute_1="value 1" attribute_1="value 2" /&gt;<br>
<br>
Attributes are achieved by placing a cluster named "#attributes" as the
first cluster element of the xml element cluster.<br>
<br>
<span style="font-weight: bold;">Scalar Elements with
Attributes</span><br>
If an xml element (having attributes) is a scalar (no child elements),
then the second cluster element must be a LabVIEW scalar with the same
name as the element cluster.<br>
<br>
<span style="font-weight: bold;">Compound Elements with
Attributes</span><br>
If an element with attributes has more than one (non-attribute) child
element, then every cluster element shall be interpreted as a child
element (rather than scalar data), even if a child element has the same
name as the parent element (cluster).<br>
<br>
<span style="font-weight: bold;">Best Attempt Parsing
(Extra and Missing XML)</span><br>
One of the features that makes EasyXML so great is that it can
gracefully handle extra and missing data elements in the XML data -
it will do it's "best attempt" to parse the XML data.<br>
<br>
In the case where there are extra XML elements or attributes that are
not present in the LabVIEW data, then they will simply be ignored -
this is a "best attempt".<br>
<br>
In the case where there are elements or attributes present in the
LabVIEW that are not present in the XML data, then the output LabVIEW
data will contain the same values passed into the Data Type and Default
Value (variant) input - this is a "best attempt".<br>
<br>
<span style="font-weight: bold;">Pretty-Print (Block
Indentation)</span><br>
When generating xml data, 2 spaces are used for block indentation
of XML entities.&nbsp; For example:<br>
<br>
&lt;Company&gt;<br>
&nbsp; &lt;Name&gt;JKI&lt;/Name&gt;<br>
&nbsp; &lt;Location&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;City&gt;San
Francisco&lt;/City&gt;<br>
&nbsp;&nbsp;&nbsp;
&lt;Country&gt;USA&lt;/Country&gt;<br>
&nbsp; &lt;/Location&gt;<br>
&lt;/Company&gt;<br>
<br>
instead of:<br>
<br>
&lt;Company&gt;<br>
&lt;Name&gt;JKI&lt;/Name&gt;<br>
&lt;Location&gt;<br>
&lt;City&gt;San Francisco&lt;/City&gt;<br>
&lt;Country&gt;USA&lt;/Country&gt;<br>
&lt;/Location&gt;<br>
&lt;/Company&gt;<br>
<br>
<span style="font-weight: bold;">Third Party Software
Dependencies</span><br style="font-weight: bold;">
The EasyXML library requires the following third party software, which
can be downloaded and installed using VIPM (<a
 href="http://jkisoft.com/vipm/" target="_blank">VI
Package Manager</a>):<br>
<ul>
  <li><span style="font-weight: bold;">OpenG String
Library</span> (oglib_string) 2.6&nbsp;or greater</li>
  <li><span style="font-weight: bold;">OpenG LabVIEW
Data Tools Library</span> (oglib_lvdata) 2.8&nbsp;or greater</li>
  <li><span style="font-weight: bold;">OpenG File
Library</span> (oglib_file) 2.8&nbsp;or greater</li>
  <li><span style="font-weight: bold;">OpenG Error
Handling Library</span> (oglib_error) 2.3&nbsp;or greater</li>
  <li><span style="font-weight: bold;">OpenG Array
Library</span> (oglib_array) 2.7&nbsp;or greater</li>
  <li><span style="font-weight: bold;">OpenG
Application Control Library</span> (oglib_appcontrol)
2.9&nbsp;or greater</li>
</ul>
These libraries are part of the <a href="http://openg.org">OpenG</a>
toolkit and are licensed under the <a
 href="http://www.opensource.org/licenses/bsd-license.php">BSD</a>
license. &nbsp;You might wish to read the following FAQ: <span
 id="tid-span-613"></span><a id="tid-link-613"
 href="http://forums.jkisoft.com/index.php?showtopic=613"
 title="This topic was started: Today, 08:33 PM. Click and hold to edit title">What
is OpenG and why does EasyXML require OpenG VIs?</a><br></p>

<hr>

<p class="Body">
JKI EasyXML Toolkit for LabVIEW<br />
Copyright &copy; 2007, <a onclick="WWW('http://jkisoft.com')" style="text-decoration: underline;
color: green; cursor: hand">JKI</a><br />
ALL RIGHTS RESERVED
</p>
<p class="Body">See the <a href="license.txt">JKI Software License Agreement</a> for more information.</p>

</body>
</html>